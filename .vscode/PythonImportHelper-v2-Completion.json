[
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "print_and_log",
        "kind": 2,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "def print_and_log(message, level=\"info\"):\n    # Removendo qualquer espaço em branco no início da mensagem\n    message = '\\n'.join([m.lstrip() for m in message.split('\\n')])\n    match level:\n        case \"info\":\n            print(message)\n            logging.info(message.strip())\n        case \"debug\":\n            print(message)\n            logging.debug(message.strip())",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "end_script",
        "kind": 2,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "def end_script(finish_code: 0):\n    match finish_code:\n        case 0:\n            print_and_log(f\"\"\"\\n*********************************************************\\n\n                        Programa finalizado com sucesso!\n                        \\n/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\\n\"\"\")\n            sys.exit(0)\n        case 1:\n            print_and_log(f\"\"\"\\n*********************************************************\\n\n                        Programa finalizado com erro!",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    formatter_class=argparse.RawTextHelpFormatter,\n    allow_abbrev=False,\n    add_help=False,\n    prog='Backup VMs',\n    usage='python backup_vm.py --vm \"NOME DA VM\" [--zip]',\n    description=\"O script realiza backup da VM informada e envia para o servidor SFTP que foi configurado no arquivo settings.cfg.\",\n    epilog=':)')\n# Configurando argumentos que podem ser passados\nparser.add_argument('--vm', required=True, metavar='\"NOME DA VM\"',",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "args = parser.parse_args()\nvm_to_backup = args.vm\nmake_zip_from_backup = args.zip\n# Iremos informar os argumentos passados ao usuário apenas após criar o arquivo de log (próximo bloco do script)\n# Pois assim poderemos gravar no log as informações passadas\n#########################################################\n# Configurando os logs do script\n#########################################################\nprint(f\"\"\"\\n/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\\n\\nIniciando arquivo de log...\"\"\")\n# Diretório onde os logs serão armazenados",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "vm_to_backup",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "vm_to_backup = args.vm\nmake_zip_from_backup = args.zip\n# Iremos informar os argumentos passados ao usuário apenas após criar o arquivo de log (próximo bloco do script)\n# Pois assim poderemos gravar no log as informações passadas\n#########################################################\n# Configurando os logs do script\n#########################################################\nprint(f\"\"\"\\n/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\\n\\nIniciando arquivo de log...\"\"\")\n# Diretório onde os logs serão armazenados\nlog_dir = \"logs\"",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "make_zip_from_backup",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "make_zip_from_backup = args.zip\n# Iremos informar os argumentos passados ao usuário apenas após criar o arquivo de log (próximo bloco do script)\n# Pois assim poderemos gravar no log as informações passadas\n#########################################################\n# Configurando os logs do script\n#########################################################\nprint(f\"\"\"\\n/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\\n\\nIniciando arquivo de log...\"\"\")\n# Diretório onde os logs serão armazenados\nlog_dir = \"logs\"\n# Criando o diretório caso não exista",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "log_dir",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "log_dir = \"logs\"\n# Criando o diretório caso não exista\nos.makedirs(log_dir, exist_ok=True)\n# Criando uma string com horário e id unico para essa execução do script\nunique_time_id = f\"{datetime.now().strftime('%d-%m-%Y__%H-%M-%S')}__{uuid.uuid4().hex}\"\n# Criando um nome para o log (formato: log__data__horário__id.log)\nlog_filename = os.path.join(\n    log_dir,\n    f\"log__{unique_time_id}.log\")\n# Configurando o logging",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "unique_time_id",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "unique_time_id = f\"{datetime.now().strftime('%d-%m-%Y__%H-%M-%S')}__{uuid.uuid4().hex}\"\n# Criando um nome para o log (formato: log__data__horário__id.log)\nlog_filename = os.path.join(\n    log_dir,\n    f\"log__{unique_time_id}.log\")\n# Configurando o logging\nlogging.basicConfig(\n    filename=log_filename,\n    level=logging.INFO,\n    encoding=\"utf-8\",",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "log_filename",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "log_filename = os.path.join(\n    log_dir,\n    f\"log__{unique_time_id}.log\")\n# Configurando o logging\nlogging.basicConfig(\n    filename=log_filename,\n    level=logging.INFO,\n    encoding=\"utf-8\",\n    format=\"%(asctime)s - %(levelname)s:\\n%(message)s\\n\"\n)",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "config = configparser.ConfigParser()\n# Tentando abrir o arquivo settings.cfg\ntry:\n    # Abrindo o aquivo\n    with open('settings.cfg') as file:\n        # Lendo o arquivo\n        config.read_file(file)\n# Caso encontre algum erro\nexcept IOError as error:\n    print_and_log(f\"\"\"\\nErro ao tentar abrir o arquivo settings.cfg:\\n",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "ftp_info",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "ftp_info = {}\nupload_backup_to_ftp = None\nclean_local_backup_after_upload = None\nmax_logs = None\nlocal_backups_base_folder_path = \"\"\n# Lendo e validando o parâmetro log_settings -> max_logs\ntry:\n    max_logs = config.getint('log_settings', 'max_logs')\nexcept ValueError:\n    print_and_log(",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "upload_backup_to_ftp",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "upload_backup_to_ftp = None\nclean_local_backup_after_upload = None\nmax_logs = None\nlocal_backups_base_folder_path = \"\"\n# Lendo e validando o parâmetro log_settings -> max_logs\ntry:\n    max_logs = config.getint('log_settings', 'max_logs')\nexcept ValueError:\n    print_and_log(\n        \"\\nErro: Parâmetro 'log_settings -> max_logs' precisa ser um número inteiro.\", \"critical\")",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "clean_local_backup_after_upload",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "clean_local_backup_after_upload = None\nmax_logs = None\nlocal_backups_base_folder_path = \"\"\n# Lendo e validando o parâmetro log_settings -> max_logs\ntry:\n    max_logs = config.getint('log_settings', 'max_logs')\nexcept ValueError:\n    print_and_log(\n        \"\\nErro: Parâmetro 'log_settings -> max_logs' precisa ser um número inteiro.\", \"critical\")\n    end_script(1)",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "max_logs",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "max_logs = None\nlocal_backups_base_folder_path = \"\"\n# Lendo e validando o parâmetro log_settings -> max_logs\ntry:\n    max_logs = config.getint('log_settings', 'max_logs')\nexcept ValueError:\n    print_and_log(\n        \"\\nErro: Parâmetro 'log_settings -> max_logs' precisa ser um número inteiro.\", \"critical\")\n    end_script(1)\n# Lendo e validando o parâmetro script_settings -> upload_backup_to_ftp",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "local_backups_base_folder_path",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "local_backups_base_folder_path = \"\"\n# Lendo e validando o parâmetro log_settings -> max_logs\ntry:\n    max_logs = config.getint('log_settings', 'max_logs')\nexcept ValueError:\n    print_and_log(\n        \"\\nErro: Parâmetro 'log_settings -> max_logs' precisa ser um número inteiro.\", \"critical\")\n    end_script(1)\n# Lendo e validando o parâmetro script_settings -> upload_backup_to_ftp\ntry:",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "logs",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "logs = sorted(glob.glob(os.path.join(log_dir, \"log_*.log\")),\n              key=os.path.getctime)\n# Caso exceda o número máximo de logs\nif len(logs) > max_logs:\n    print_and_log(f\"\"\"Quantidade de logs excedida!\"\"\")\n    # Pegar os logs excedentes\n    logs_a_excluir = logs[:len(logs) - max_logs]\n    # Iterar sobre cada log\n    for log in logs_a_excluir:\n        # Excluir o log",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "path = os.getcwd()\n# Arazendando o modo de encoding do sistema em que o script está rodando\n# (normalmente UTF-8, porém o UTF-8 dá erro no powershell,\n# se o script rodar no windows vai retornar encoding: CodePage850,\n# vai rodar com sucesso porém os acentos no log vão ficar bugados.)\nencoding = os.device_encoding(1)\n# Nome da pasta raiz onde será armazenado todos os backups\nbackup_script_name = \"script_teste\"\n# Nome da pasta que será armazenado este backup da VM\nbackup_folder_name = f\"{vm_to_backup}__{unique_time_id}\"",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "encoding",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "encoding = os.device_encoding(1)\n# Nome da pasta raiz onde será armazenado todos os backups\nbackup_script_name = \"script_teste\"\n# Nome da pasta que será armazenado este backup da VM\nbackup_folder_name = f\"{vm_to_backup}__{unique_time_id}\"\n# Armazenando o caminho completo do backup para usar depois\nbackup_folder_full_path = f\"{local_backups_base_folder_path}{backup_folder_name}\"\nprint_and_log(f\"\"\"Abrindo o script de backup no powershell...\"\"\")\np = subprocess.run(\n    [\"powershell.exe\",",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "backup_script_name",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "backup_script_name = \"script_teste\"\n# Nome da pasta que será armazenado este backup da VM\nbackup_folder_name = f\"{vm_to_backup}__{unique_time_id}\"\n# Armazenando o caminho completo do backup para usar depois\nbackup_folder_full_path = f\"{local_backups_base_folder_path}{backup_folder_name}\"\nprint_and_log(f\"\"\"Abrindo o script de backup no powershell...\"\"\")\np = subprocess.run(\n    [\"powershell.exe\",\n     \"-NoProfile\",\n     \"-ExecutionPolicy\", \"Bypass\",",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "backup_folder_name",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "backup_folder_name = f\"{vm_to_backup}__{unique_time_id}\"\n# Armazenando o caminho completo do backup para usar depois\nbackup_folder_full_path = f\"{local_backups_base_folder_path}{backup_folder_name}\"\nprint_and_log(f\"\"\"Abrindo o script de backup no powershell...\"\"\")\np = subprocess.run(\n    [\"powershell.exe\",\n     \"-NoProfile\",\n     \"-ExecutionPolicy\", \"Bypass\",\n     \"-File\", f\"{path}\\\\{backup_script_name}.ps1\", f\"{vm_to_backup}\", f\"{local_backups_base_folder_path}\", f\"{backup_folder_name}\"],\n    capture_output=True, text=True, encoding=encoding",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "backup_folder_full_path",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "backup_folder_full_path = f\"{local_backups_base_folder_path}{backup_folder_name}\"\nprint_and_log(f\"\"\"Abrindo o script de backup no powershell...\"\"\")\np = subprocess.run(\n    [\"powershell.exe\",\n     \"-NoProfile\",\n     \"-ExecutionPolicy\", \"Bypass\",\n     \"-File\", f\"{path}\\\\{backup_script_name}.ps1\", f\"{vm_to_backup}\", f\"{local_backups_base_folder_path}\", f\"{backup_folder_name}\"],\n    capture_output=True, text=True, encoding=encoding\n)\nif p.stderr:",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "p = subprocess.run(\n    [\"powershell.exe\",\n     \"-NoProfile\",\n     \"-ExecutionPolicy\", \"Bypass\",\n     \"-File\", f\"{path}\\\\{backup_script_name}.ps1\", f\"{vm_to_backup}\", f\"{local_backups_base_folder_path}\", f\"{backup_folder_name}\"],\n    capture_output=True, text=True, encoding=encoding\n)\nif p.stderr:\n    print_and_log(\"\\nErro ao executar backup!\", \"critical\")\n    print_and_log(",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "telegram_bot_token",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "telegram_bot_token = \"7264342339:AAHkYJaFgkQNQmYcIVY2KX6zYN4FzNgLW5s\"\ntelegram_group_chat_id = 6674522493\nmessage = f\"(TESTE)\\n✅ SUCESSO: Backup da VM {vm_to_backup} realizado com sucesso!\\n(*￣▽￣*)ブ\"\nurl = f\"https://api.telegram.org/bot{telegram_bot_token}/sendMessage\"\nresponse = requests.post(\n    url=url, data={'chat_id': telegram_group_chat_id, 'text': message})\n# Throw an exception if Telegram API fails\nresponse.raise_for_status()\nprint(response.json())\n# --------------------------------------------------------",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "telegram_group_chat_id",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "telegram_group_chat_id = 6674522493\nmessage = f\"(TESTE)\\n✅ SUCESSO: Backup da VM {vm_to_backup} realizado com sucesso!\\n(*￣▽￣*)ブ\"\nurl = f\"https://api.telegram.org/bot{telegram_bot_token}/sendMessage\"\nresponse = requests.post(\n    url=url, data={'chat_id': telegram_group_chat_id, 'text': message})\n# Throw an exception if Telegram API fails\nresponse.raise_for_status()\nprint(response.json())\n# --------------------------------------------------------\n# Finalizando o programa",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "message = f\"(TESTE)\\n✅ SUCESSO: Backup da VM {vm_to_backup} realizado com sucesso!\\n(*￣▽￣*)ブ\"\nurl = f\"https://api.telegram.org/bot{telegram_bot_token}/sendMessage\"\nresponse = requests.post(\n    url=url, data={'chat_id': telegram_group_chat_id, 'text': message})\n# Throw an exception if Telegram API fails\nresponse.raise_for_status()\nprint(response.json())\n# --------------------------------------------------------\n# Finalizando o programa\n# --------------------------------------------------------",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "url = f\"https://api.telegram.org/bot{telegram_bot_token}/sendMessage\"\nresponse = requests.post(\n    url=url, data={'chat_id': telegram_group_chat_id, 'text': message})\n# Throw an exception if Telegram API fails\nresponse.raise_for_status()\nprint(response.json())\n# --------------------------------------------------------\n# Finalizando o programa\n# --------------------------------------------------------\n# Finaliza o script",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "backup_vm",
        "description": "backup_vm",
        "peekOfCode": "response = requests.post(\n    url=url, data={'chat_id': telegram_group_chat_id, 'text': message})\n# Throw an exception if Telegram API fails\nresponse.raise_for_status()\nprint(response.json())\n# --------------------------------------------------------\n# Finalizando o programa\n# --------------------------------------------------------\n# Finaliza o script\nend_script(0)",
        "detail": "backup_vm",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "test_args",
        "description": "test_args",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    formatter_class=argparse.RawTextHelpFormatter,\n    allow_abbrev=False,\n    add_help=False,\n    prog='Backup VMs',\n    usage='python backup_vm.py --vm \"NOME DA VM\" [--zip]',\n    description=\"O script realiza backup da VM informada e envia para o servidor SFTP que foi configurado no arquivo settings.cfg.\",\n    epilog=':)')\nparser.add_argument('--vm', required=True, metavar='\"NOME DA VM\"',\n                    help='(Obrigatório) Nome da VM que deseja fazer backup.')",
        "detail": "test_args",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "test_args",
        "description": "test_args",
        "peekOfCode": "args = parser.parse_args()\nprint(f\"\"\"---> Argumentos passados para o script:\nNome da VM para realizar backup -> {args.vm}\nDeve comprimir o backup em zip? -> {args.zip}\"\"\")",
        "detail": "test_args",
        "documentation": {}
    }
]